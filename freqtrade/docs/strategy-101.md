# Freqtrade Strategies 101: 戦略開発のクイック スタート

このクイック スタートでは、読者が取引の基本に精通しており、以下の文書を読んでいることを前提としています。 
[Freqtrade の基本](bot-basics.md) ページ。

## 必要な知識

Freqtrade の戦略は、暗号通貨「資産」を売買するためのロジックを定義する Python クラスです。

資産は「コイン」と「ステーク」を表す「ペア」として定義されます。コインは、別の通貨を賭け金として使用して取引している資産です。

データは取引所によって「キャンドル」の形式で提供され、「日付」、「始値」、「高値」、「安値」、「終値」、および「ボリューム」の 6 つの値で構成されます。

「テクニカル分析」機能は、さまざまな計算式や統計式を使用してローソク足データを分析し、「インジケーター」と呼ばれる二次的な値を生成します。

インジケーターは資産ペアのローソク足で分析され、「シグナル」が生成されます。

シグナルは、暗号通貨の「取引所」で「注文」、つまり「取引」に変換されます。

Freqtrade は「ロング」取引と「ショート」取引の両方をサポートしているため、「買い」と「売り」の代わりに「エントリー」と「エグジット」という用語を使用します。

- **ロング**: 賭け金に基づいてコインを購入します。 USDT を賭け金として使用してコイン BTC を購入し、支払った金額よりも高いレートでコインを売ることで利益を得ることができます。ロングトレードでは、賭け金に対してコインの価値が上昇することで利益が得られます。
- **短い**: 取引所からコインの形で資本を借り、後でコインの賭け金を返済します。ショートトレードでは、賭け金に対してコインの価値が下がることで利益が得られます（より低い金利でローンを返済することになります）。

Freqtrade は特定の取引所のスポット市場と先物市場をサポートしていますが、簡単にするためにスポット (ロング) 取引のみに焦点を当てます。

## 基本戦略の構成

### メインデータフレーム

Freqtrade 戦略は、「データフレーム」として知られる行と列を含む表形式のデータ構造を使用して、取引に参加および取引を終了するためのシグナルを生成します。

構成されたペアリスト内の各ペアには独自のデータフレームがあります。データフレームは「date」列によってインデックス付けされます。 「2024-06-31 12:00」。

次の 5 列は、「始値」、「高値」、「安値」、「終値」、および「ボリューム」 (OHLCV) データを表します。

### インジケーター値を入力する

「populate_indicators」関数は、テクニカル分析インジケーターの値を表す列をデータフレームに追加します。

一般的な指標の例には、相対力指数、ボリンジャーバンド、マネーフロー指数、移動平均、平均トゥルーレンジなどがあります。

列は、テクニカル分析関数を呼び出すことによってデータフレームに追加されます。 ta-lib の RSI 関数 `ta.RSI()` を使用し、それらを列名に割り当てます。 「rsi」
```python
dataframe['rsi'] = ta.RSI(dataframe)
```
???ヒント「テクニカル分析ライブラリ」
    ライブラリーが異なれば、インジケーター値を生成する方法も異なります。理解するには各ライブラリのドキュメントを確認してください。
    それを戦略に組み込む方法。 [Freqtrade 戦略例](https://github.com/freqtrade/freqtrade-strategies) をチェックしてアイデアを得ることができます。

### エントリーシグナルを入力する

「populate_entry_trend」関数はエントリーシグナルの条件を定義します。

データフレーム列「enter_long」がデータフレームに追加され、この列に値「1」がある場合、Freqtrade はエントリー信号を認識します。

???ヒント「ショート」
    ショートトレードを入力するには、「enter_short」列を使用します。

### 出口シグナルを設定する

`populate_exit_trend` 関数は、終了シグナルの条件を定義します。

データフレーム列「exit_long」がデータフレームに追加され、この列に「1」の値がある場合、Freqtrade は終了シグナルを認識します。

???ヒント「ショート」
    ショートトレードを終了するには、「exit_short」列を使用します。

## シンプルな戦略

Freqtrade 戦略の最小限の例を次に示します。
```python
from freqtrade.strategy import IStrategy
from pandas import DataFrame
import talib.abstract as ta

class MyStrategy(IStrategy):

    timeframe = '15m'

    # set the initial stoploss to -10%
    stoploss = -0.10

    # exit profitable positions at any time when the profit is greater than 1%
    minimal_roi = {"0": 0.01}

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # generate values for technical analysis indicators
        dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)

        return dataframe

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # generate entry signals based on indicator values
        dataframe.loc[
            (dataframe['rsi'] < 30),
            'enter_long'] = 1

        return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # generate exit signals based on indicator values
        dataframe.loc[
            (dataframe['rsi'] > 70),
            'exit_long'] = 1

        return dataframe
```
## 取引を行う

シグナルが見つかると (エントリーまたはエグジット列の「1」)、Freqtrade は注文、つまり「トレード」または「ポジション」の作成を試みます。

新しい取引ポジションはそれぞれ「スロット」を占有します。スロットは、同時に開くことができる新しい取引の最大数を表します。

スロットの数は、`max_open_trades` [configuration](configuration.md) オプションによって定義されます。

ただし、シグナルの生成によって必ずしも取引注文が作成されるとは限らないさまざまなシナリオが存在する可能性があります。これらには次のものが含まれます。

- 資産を購入するのに十分な残りの賭け金、または資産を売却するのに十分な資金がウォレットにない（手数料を含む）
- 新しい取引を開くのに十分な空きスロットが残っていない (開いているポジションの数が `max_open_trades` オプションに等しい)
- ペアのオープントレードがすでに存在します (Freqtrade はポジションをスタックできませんが、[既存のポジションを調整](strategy-callbacks.md#adjust-trade-position) することはできます)
- エントリーシグナルとエグジットシグナルが同じローソク足に存在する場合、それらは[衝突](strategy-customization.md#colliding-signals)とみなされ、注文は上げられません。
- 関連する [entry](strategy-callbacks.md#trade-entry-buy-order-confirmation) または [exit](strategy-callbacks.md#trade-exit-sell-order-confirmation) コールバックのいずれかを使用して指定したロジックにより、ストラテジーは取引注文を積極的に拒否します。

詳細については、[戦略のカスタマイズ](strategy-customization.md) ドキュメントを参照してください。

## バックテストとフォワードテスト

戦略策定は、人間の「直感」をコンピューター制御の機能に変えるため、長くてイライラするプロセスになる可能性があります。
(「アルゴ」) 戦略は必ずしも単純ではありません。

したがって、戦略をテストして、意図したとおりに機能することを確認する必要があります。

Freqtrade には 2 つのテスト モードがあります。

- **バックテスト**: [取引所からダウンロード](data-download.md)した履歴データを使用するバックテストは、戦略のパフォーマンスを評価する簡単な方法です。ただし、結果を歪めることは非常に簡単であるため、戦略が実際よりもはるかに収益性が高いように見えます。詳細については、[バックテストのドキュメント](backtesting.md) を確認してください。
- **ドライ ラン**: _フォワード テスト_と呼ばれることが多く、ドライ ランでは交換からのリアルタイム データが使用されます。ただし、取引につながるシグナルはすべて Freqtrade によって通常どおり追跡されますが、取引所自体で取引が開始されることはありません。フォワード テストはリアルタイムで実行されるため、結果が得られるまでに時間がかかりますが、バックテストよりも**潜在的な**パフォーマンスを示す信頼性の高い指標となります。

ドライ ランは、[設定](configuration.md#using-dry-run-mode) で `dry_run` を true に設定することで有効になります。

!!! Warning "バックテストは非常に不正確になる可能性がある"
バックテストの結果が現実と一致しない場合には、さまざまな理由が考えられます。 [バックテストの前提条件](backtesting.md#assumptions-made-by-backtesting) および [一般的な戦略の間違い](strategy-customization.md#common-missing-when-developing-strategies) のドキュメントを確認してください。
    Freqtrade 戦略をリストし、ランク付けしている Web サイトの中には、印象的なバックテスト結果を示しているものがあります。これらの結果が達成可能または現実的であると想定しないでください。

???ヒント「便利なコマンド」
    Freqtrade には、戦略の基本的な欠陥をチェックするための 2 つの便利なコマンドが含まれています: [lookahead-analysis](lookahead-analysis.md) と [recursive-analysis](recursive-analysis.md) です。

### バックテストと予行演習の結果の評価

バックテストの後に必ず戦略をドライランし、バックテストとドライランの結果が十分に類似しているかどうかを確認します。

大きな違いがある場合は、エントリーシグナルとエグジットシグナルに一貫性があり、2 つのモード間で同じローソク足に表示されることを確認してください。ただし、ドライランとバックテストの間には常に違いがあります。

- バックテストはすべての注文が約定したことを前提としています。ドライランでは、指値注文を使用している場合、または取引所にボリュームがない場合は、これが当てはまらない場合があります。
- ローソク足の終値でのエントリーシグナルに続いて、バックテストでは、取引が次のローソク足の始値でエントリーすると想定されます (戦略にカスタム価格コールバックがある場合を除く)。予行演習では、シグナルと取引開始の間に遅延が生じることがよくあります。
  これは、メインのタイムフレームに新しいローソク足が入ったとき、たとえば、 Freqtrade がすべてのペア データフレームを分析するのに 5 分ごとに時間がかかります。したがって、Freqtrade は数秒以内に取引を開始しようとします (できるだけ遅延が少ないことが理想的です)。
  キャンドルが開いた後。
- ドライランでのエントリー率はバックテストと一致しない可能性があるため、利益の計算も異なることになります。したがって、ROI、ストップロス、トレーリングストップロス、およびコールバックエグジットが同一でなくても正常です。
- 新しいローソク足が入ってから、シグナルが上がって取引が開始されるまでの間に計算上の「ラグ」が大きくなるほど、価格の予測不可能性が大きくなります。コンピュータが番号のデータを処理するのに十分な能力があることを確認してください 
  妥当な時間内にペアリストにあるペアの数。データ処理に大幅な遅延がある場合、Freqtrade はログで警告します。

## 実行中のボットの制御または監視

ボットがドライ モードまたはライブ モードで実行されると、Freqtrade には実行中のボットを制御または監視するための 6 つのメカニズムがあります。

- **[FreqUI](freq-ui.md)**: 最も簡単に始めることができる FreqUI は、ボットの現在のアクティビティを確認および制御するための Web インターフェイスです。
- **[Telegram](telegram-usage.md)**: モバイル デバイスでは、ボット アクティビティに関するアラートを取得し、特定の側面を制御するために Telegram 統合を利用できます。
- **[FTUI](https://github.com/freqtrade/ftui)**: FTUI は Freqtrade へのターミナル (コマンド ライン) インターフェイスであり、実行中のボットのみを監視できます。
- **[freqtrade-client](rest-api.md#customing-the-api)**: REST API の Python 実装。これにより、Python アプリまたはコマンド ラインからリクエストを作成したり、ボットの応答を消費したりすることが簡単になります。
- **[REST API エンドポイント](rest-api.md#available-endpoints)**: REST API を使用すると、プログラマーは Freqtrade ボットと対話するための独自のツールを開発できます。
- **[Webhook](webhook-config.md)**: Freqtrade は他のサービスに情報を送信できます。 Discord、Webhook による。

### ログ

Freqtrade は、何が起こっているかを理解するのに役立つ広範なデバッグ ログを生成します。ボット ログに表示される可能性のある情報とエラー メッセージについてよく理解してください。

デフォルトでは、ログは標準出力 (コマンドライン) で行われます。代わりにファイルに書き出す場合は、「trade」コマンドを含む多くの freqtrade コマンドで、ファイルに書き込むための「--logfile」オプションを受け入れます。

例については、[FAQ](faq.md#how-do-i-search-the-bot-logs-for-something) を確認してください。

## 最終的な考え

アルゴ取引は難しく、複数のシナリオで戦略を有利に機能させるには時間と労力がかかるため、ほとんどの公開戦略はパフォーマンスが良くありません。

したがって、パフォーマンスを評価する方法として公開戦略を採用し、バックテストを使用することには問題が生じることがよくあります。ただし、Freqtrade は、意思決定とデューデリジェンスの実行に役立つ便利な方法を提供します。

収益性を達成するにはさまざまな方法がありますが、パフォーマンスの悪い戦略を修正する単一のヒント、トリック、または設定オプションはありません。

Freqtrade は、大規模で役立つコミュニティを備えたオープン ソース プラットフォームです。必ず [discord チャンネル](https://discord.gg/p7nuUNVfP7) にアクセスして、あなたの戦略を他の人と話し合ってください。

いつものように、失っても構わない額だけを投資してください。

## 結論

Freqtrade で戦略を開発するには、テクニカル指標に基づいてエントリーシグナルとエグジットシグナルを定義する必要があります。上記で概説した構造と方法に従うことで、独自の取引戦略を作成してテストできます。

一般的な質問と回答は、[FAQ](faq.md) でご覧いただけます。

続行するには、より詳細な [Freqtrade 戦略カスタマイズ ドキュメント](strategy-customization.md) を参照してください。
